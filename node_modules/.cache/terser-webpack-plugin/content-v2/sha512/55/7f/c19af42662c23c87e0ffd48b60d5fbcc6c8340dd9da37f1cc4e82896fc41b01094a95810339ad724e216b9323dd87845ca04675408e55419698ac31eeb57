{"code":"!function(e){var n={};function t(r){if(n[r])return n[r].exports;var a=n[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&\"object\"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:e}),2&n&&\"string\"!=typeof e)for(var a in e)t.d(r,a,function(n){return e[n]}.bind(null,a));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,\"a\",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p=\"\",t(t.s=\"./src/client/client.ts\")}({\"./node_modules/process/browser.js\":\n/*!*****************************************!*\\\n  !*** ./node_modules/process/browser.js ***!\n  \\*****************************************/\n/*! no static exports found */function(module,exports){eval(\"// shim for using process in browser\\nvar process = module.exports = {};\\n\\n// cached from whatever global is present so that test runners that stub it\\n// don't break things.  But we need to wrap it in a try catch in case it is\\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\\n// function because try/catches deoptimize in certain engines.\\n\\nvar cachedSetTimeout;\\nvar cachedClearTimeout;\\n\\nfunction defaultSetTimout() {\\n    throw new Error('setTimeout has not been defined');\\n}\\nfunction defaultClearTimeout () {\\n    throw new Error('clearTimeout has not been defined');\\n}\\n(function () {\\n    try {\\n        if (typeof setTimeout === 'function') {\\n            cachedSetTimeout = setTimeout;\\n        } else {\\n            cachedSetTimeout = defaultSetTimout;\\n        }\\n    } catch (e) {\\n        cachedSetTimeout = defaultSetTimout;\\n    }\\n    try {\\n        if (typeof clearTimeout === 'function') {\\n            cachedClearTimeout = clearTimeout;\\n        } else {\\n            cachedClearTimeout = defaultClearTimeout;\\n        }\\n    } catch (e) {\\n        cachedClearTimeout = defaultClearTimeout;\\n    }\\n} ())\\nfunction runTimeout(fun) {\\n    if (cachedSetTimeout === setTimeout) {\\n        //normal enviroments in sane situations\\n        return setTimeout(fun, 0);\\n    }\\n    // if setTimeout wasn't available but was latter defined\\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\\n        cachedSetTimeout = setTimeout;\\n        return setTimeout(fun, 0);\\n    }\\n    try {\\n        // when when somebody has screwed with setTimeout but no I.E. maddness\\n        return cachedSetTimeout(fun, 0);\\n    } catch(e){\\n        try {\\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\\n            return cachedSetTimeout.call(null, fun, 0);\\n        } catch(e){\\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\\n            return cachedSetTimeout.call(this, fun, 0);\\n        }\\n    }\\n\\n\\n}\\nfunction runClearTimeout(marker) {\\n    if (cachedClearTimeout === clearTimeout) {\\n        //normal enviroments in sane situations\\n        return clearTimeout(marker);\\n    }\\n    // if clearTimeout wasn't available but was latter defined\\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\\n        cachedClearTimeout = clearTimeout;\\n        return clearTimeout(marker);\\n    }\\n    try {\\n        // when when somebody has screwed with setTimeout but no I.E. maddness\\n        return cachedClearTimeout(marker);\\n    } catch (e){\\n        try {\\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\\n            return cachedClearTimeout.call(null, marker);\\n        } catch (e){\\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\\n            return cachedClearTimeout.call(this, marker);\\n        }\\n    }\\n\\n\\n\\n}\\nvar queue = [];\\nvar draining = false;\\nvar currentQueue;\\nvar queueIndex = -1;\\n\\nfunction cleanUpNextTick() {\\n    if (!draining || !currentQueue) {\\n        return;\\n    }\\n    draining = false;\\n    if (currentQueue.length) {\\n        queue = currentQueue.concat(queue);\\n    } else {\\n        queueIndex = -1;\\n    }\\n    if (queue.length) {\\n        drainQueue();\\n    }\\n}\\n\\nfunction drainQueue() {\\n    if (draining) {\\n        return;\\n    }\\n    var timeout = runTimeout(cleanUpNextTick);\\n    draining = true;\\n\\n    var len = queue.length;\\n    while(len) {\\n        currentQueue = queue;\\n        queue = [];\\n        while (++queueIndex < len) {\\n            if (currentQueue) {\\n                currentQueue[queueIndex].run();\\n            }\\n        }\\n        queueIndex = -1;\\n        len = queue.length;\\n    }\\n    currentQueue = null;\\n    draining = false;\\n    runClearTimeout(timeout);\\n}\\n\\nprocess.nextTick = function (fun) {\\n    var args = new Array(arguments.length - 1);\\n    if (arguments.length > 1) {\\n        for (var i = 1; i < arguments.length; i++) {\\n            args[i - 1] = arguments[i];\\n        }\\n    }\\n    queue.push(new Item(fun, args));\\n    if (queue.length === 1 && !draining) {\\n        runTimeout(drainQueue);\\n    }\\n};\\n\\n// v8 likes predictible objects\\nfunction Item(fun, array) {\\n    this.fun = fun;\\n    this.array = array;\\n}\\nItem.prototype.run = function () {\\n    this.fun.apply(null, this.array);\\n};\\nprocess.title = 'browser';\\nprocess.browser = true;\\nprocess.env = {};\\nprocess.argv = [];\\nprocess.version = ''; // empty string to avoid regexp issues\\nprocess.versions = {};\\n\\nfunction noop() {}\\n\\nprocess.on = noop;\\nprocess.addListener = noop;\\nprocess.once = noop;\\nprocess.off = noop;\\nprocess.removeListener = noop;\\nprocess.removeAllListeners = noop;\\nprocess.emit = noop;\\nprocess.prependListener = noop;\\nprocess.prependOnceListener = noop;\\n\\nprocess.listeners = function (name) { return [] }\\n\\nprocess.binding = function (name) {\\n    throw new Error('process.binding is not supported');\\n};\\n\\nprocess.cwd = function () { return '/' };\\nprocess.chdir = function (dir) {\\n    throw new Error('process.chdir is not supported');\\n};\\nprocess.umask = function() { return 0; };\\n\\n\\n//# sourceURL=webpack:///./node_modules/process/browser.js?\")},\"./node_modules/setimmediate/setImmediate.js\":\n/*!***************************************************!*\\\n  !*** ./node_modules/setimmediate/setImmediate.js ***!\n  \\***************************************************/\n/*! no static exports found */function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\\n    \"use strict\";\\n\\n    if (global.setImmediate) {\\n        return;\\n    }\\n\\n    var nextHandle = 1; // Spec says greater than zero\\n    var tasksByHandle = {};\\n    var currentlyRunningATask = false;\\n    var doc = global.document;\\n    var registerImmediate;\\n\\n    function setImmediate(callback) {\\n      // Callback can either be a function or a string\\n      if (typeof callback !== \"function\") {\\n        callback = new Function(\"\" + callback);\\n      }\\n      // Copy function arguments\\n      var args = new Array(arguments.length - 1);\\n      for (var i = 0; i < args.length; i++) {\\n          args[i] = arguments[i + 1];\\n      }\\n      // Store and register the task\\n      var task = { callback: callback, args: args };\\n      tasksByHandle[nextHandle] = task;\\n      registerImmediate(nextHandle);\\n      return nextHandle++;\\n    }\\n\\n    function clearImmediate(handle) {\\n        delete tasksByHandle[handle];\\n    }\\n\\n    function run(task) {\\n        var callback = task.callback;\\n        var args = task.args;\\n        switch (args.length) {\\n        case 0:\\n            callback();\\n            break;\\n        case 1:\\n            callback(args[0]);\\n            break;\\n        case 2:\\n            callback(args[0], args[1]);\\n            break;\\n        case 3:\\n            callback(args[0], args[1], args[2]);\\n            break;\\n        default:\\n            callback.apply(undefined, args);\\n            break;\\n        }\\n    }\\n\\n    function runIfPresent(handle) {\\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\\n        // So if we\\'re currently running a task, we\\'ll need to delay this invocation.\\n        if (currentlyRunningATask) {\\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\\n            // \"too much recursion\" error.\\n            setTimeout(runIfPresent, 0, handle);\\n        } else {\\n            var task = tasksByHandle[handle];\\n            if (task) {\\n                currentlyRunningATask = true;\\n                try {\\n                    run(task);\\n                } finally {\\n                    clearImmediate(handle);\\n                    currentlyRunningATask = false;\\n                }\\n            }\\n        }\\n    }\\n\\n    function installNextTickImplementation() {\\n        registerImmediate = function(handle) {\\n            process.nextTick(function () { runIfPresent(handle); });\\n        };\\n    }\\n\\n    function canUsePostMessage() {\\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\\n        // where `global.postMessage` means something completely different and can\\'t be used for this purpose.\\n        if (global.postMessage && !global.importScripts) {\\n            var postMessageIsAsynchronous = true;\\n            var oldOnMessage = global.onmessage;\\n            global.onmessage = function() {\\n                postMessageIsAsynchronous = false;\\n            };\\n            global.postMessage(\"\", \"*\");\\n            global.onmessage = oldOnMessage;\\n            return postMessageIsAsynchronous;\\n        }\\n    }\\n\\n    function installPostMessageImplementation() {\\n        // Installs an event handler on `global` for the `message` event: see\\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\\n\\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\\n        var onGlobalMessage = function(event) {\\n            if (event.source === global &&\\n                typeof event.data === \"string\" &&\\n                event.data.indexOf(messagePrefix) === 0) {\\n                runIfPresent(+event.data.slice(messagePrefix.length));\\n            }\\n        };\\n\\n        if (global.addEventListener) {\\n            global.addEventListener(\"message\", onGlobalMessage, false);\\n        } else {\\n            global.attachEvent(\"onmessage\", onGlobalMessage);\\n        }\\n\\n        registerImmediate = function(handle) {\\n            global.postMessage(messagePrefix + handle, \"*\");\\n        };\\n    }\\n\\n    function installMessageChannelImplementation() {\\n        var channel = new MessageChannel();\\n        channel.port1.onmessage = function(event) {\\n            var handle = event.data;\\n            runIfPresent(handle);\\n        };\\n\\n        registerImmediate = function(handle) {\\n            channel.port2.postMessage(handle);\\n        };\\n    }\\n\\n    function installReadyStateChangeImplementation() {\\n        var html = doc.documentElement;\\n        registerImmediate = function(handle) {\\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it\\'s been called.\\n            var script = doc.createElement(\"script\");\\n            script.onreadystatechange = function () {\\n                runIfPresent(handle);\\n                script.onreadystatechange = null;\\n                html.removeChild(script);\\n                script = null;\\n            };\\n            html.appendChild(script);\\n        };\\n    }\\n\\n    function installSetTimeoutImplementation() {\\n        registerImmediate = function(handle) {\\n            setTimeout(runIfPresent, 0, handle);\\n        };\\n    }\\n\\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\\n\\n    // Don\\'t get fooled by e.g. browserify environments.\\n    if ({}.toString.call(global.process) === \"[object process]\") {\\n        // For Node.js before 0.9\\n        installNextTickImplementation();\\n\\n    } else if (canUsePostMessage()) {\\n        // For non-IE10 modern browsers\\n        installPostMessageImplementation();\\n\\n    } else if (global.MessageChannel) {\\n        // For web workers, where supported\\n        installMessageChannelImplementation();\\n\\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\\n        // For IE 6â€“8\\n        installReadyStateChangeImplementation();\\n\\n    } else {\\n        // For older browsers\\n        installSetTimeoutImplementation();\\n    }\\n\\n    attachTo.setImmediate = setImmediate;\\n    attachTo.clearImmediate = clearImmediate;\\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\\n\\n//# sourceURL=webpack:///./node_modules/setimmediate/setImmediate.js?')},\"./node_modules/timers-browserify/main.js\":\n/*!************************************************!*\\\n  !*** ./node_modules/timers-browserify/main.js ***!\n  \\************************************************/\n/*! no static exports found */function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\\n            (typeof self !== \"undefined\" && self) ||\\n            window;\\nvar apply = Function.prototype.apply;\\n\\n// DOM APIs, for completeness\\n\\nexports.setTimeout = function() {\\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\\n};\\nexports.setInterval = function() {\\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\\n};\\nexports.clearTimeout =\\nexports.clearInterval = function(timeout) {\\n  if (timeout) {\\n    timeout.close();\\n  }\\n};\\n\\nfunction Timeout(id, clearFn) {\\n  this._id = id;\\n  this._clearFn = clearFn;\\n}\\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\\nTimeout.prototype.close = function() {\\n  this._clearFn.call(scope, this._id);\\n};\\n\\n// Does not start the time, just sets up the members needed.\\nexports.enroll = function(item, msecs) {\\n  clearTimeout(item._idleTimeoutId);\\n  item._idleTimeout = msecs;\\n};\\n\\nexports.unenroll = function(item) {\\n  clearTimeout(item._idleTimeoutId);\\n  item._idleTimeout = -1;\\n};\\n\\nexports._unrefActive = exports.active = function(item) {\\n  clearTimeout(item._idleTimeoutId);\\n\\n  var msecs = item._idleTimeout;\\n  if (msecs >= 0) {\\n    item._idleTimeoutId = setTimeout(function onTimeout() {\\n      if (item._onTimeout)\\n        item._onTimeout();\\n    }, msecs);\\n  }\\n};\\n\\n// setimmediate attaches itself to the global object\\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\\n// On some exotic environments, it\\'s not clear which object `setimmediate` was\\n// able to install onto.  Search each possibility in the same order as the\\n// `setimmediate` library.\\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\\n                       (this && this.setImmediate);\\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\\n                         (this && this.clearImmediate);\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\\n\\n//# sourceURL=webpack:///./node_modules/timers-browserify/main.js?')},\"./node_modules/webpack/buildin/global.js\":\n/*!***********************************!*\\\n  !*** (webpack)/buildin/global.js ***!\n  \\***********************************/\n/*! no static exports found */function(module,exports){eval('var g;\\n\\n// This works in non-strict mode\\ng = (function() {\\n\\treturn this;\\n})();\\n\\ntry {\\n\\t// This works if eval is allowed (see CSP)\\n\\tg = g || new Function(\"return this\")();\\n} catch (e) {\\n\\t// This works if the window reference is available\\n\\tif (typeof window === \"object\") g = window;\\n}\\n\\n// g can still be undefined, but nothing to do about it...\\n// We return undefined, instead of nothing here, so it\\'s\\n// easier to handle this case. if(!global) { ...}\\n\\nmodule.exports = g;\\n\\n\\n//# sourceURL=webpack:///(webpack)/buildin/global.js?')},\"./src/client/client.ts\":\n/*!******************************!*\\\n  !*** ./src/client/client.ts ***!\n  \\******************************/\n/*! no static exports found */function(module,exports,__webpack_require__){\"use strict\";eval('/* WEBPACK VAR INJECTION */(function(global) {\\r\\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\\r\\n    if (k2 === undefined) k2 = k;\\r\\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\\r\\n}) : (function(o, m, k, k2) {\\r\\n    if (k2 === undefined) k2 = k;\\r\\n    o[k2] = m[k];\\r\\n}));\\r\\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\\r\\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\\r\\n}) : function(o, v) {\\r\\n    o[\"default\"] = v;\\r\\n});\\r\\nvar __importStar = (this && this.__importStar) || function (mod) {\\r\\n    if (mod && mod.__esModule) return mod;\\r\\n    var result = {};\\r\\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\\r\\n    __setModuleDefault(result, mod);\\r\\n    return result;\\r\\n};\\r\\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\\r\\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\\r\\n    return new (P || (P = Promise))(function (resolve, reject) {\\r\\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\\r\\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\\r\\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\\r\\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\\r\\n    });\\r\\n};\\r\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\r\\nconst Koi = __importStar(__webpack_require__(/*! ../shared/shared */ \"./src/shared/shared.ts\"));\\r\\nexports = global.exports;\\r\\nconst Notify = (text) => {\\r\\n    SetNotificationTextEntry(\"STRING\");\\r\\n    AddTextComponentString(text);\\r\\n    return DrawNotification(false, false);\\r\\n};\\r\\nconst miid = (x, y, width, height, scale, text, r, g, b, a, outline) => {\\r\\n    SetTextFont(4);\\r\\n    SetTextProportional(false);\\r\\n    SetTextScale(scale, scale);\\r\\n    SetTextColour(0, 0, 0, 255);\\r\\n    SetTextEdge(1, 0, 0, 0, 255);\\r\\n    SetTextDropShadow();\\r\\n    SetTextOutline();\\r\\n    SetTextEntry(\"STRING\");\\r\\n    AddTextComponentString(text);\\r\\n    DrawText(x - width / 2, y - height / 2 + 0.005);\\r\\n};\\r\\non(\"onClientGameTypeStart\", () => {\\r\\n    let spawnPos = [-275.522, 6635.835, 7.425];\\r\\n    exports.spawnmanager.setAutoSpawnCallback(() => {\\r\\n        exports.spawnmanager.spawnPlayer({\\r\\n            x: spawnPos[0],\\r\\n            y: spawnPos[1],\\r\\n            z: spawnPos[2],\\r\\n            model: \"a_m_m_skater_01\",\\r\\n        }, () => {\\r\\n            emit(\"chat:addMessage\", {\\r\\n                args: [\"Welcome to the party!~\"],\\r\\n            });\\r\\n        });\\r\\n    });\\r\\n    exports.spawnmanager.setAutoSpawn(true);\\r\\n    exports.spawnmanager.forceRespawn();\\r\\n});\\r\\nonNet(\"Koi::Client:GetServerCallback\", (callback) => {\\r\\n    console.log(callback);\\r\\n    callback();\\r\\n});\\r\\nsetTick(() => {\\r\\n    miid(0.815, 1.435, 1.0, 1.0, 0.5, \"~b~ID:~r~  \" + GetPlayerServerId(NetworkGetEntityOwner(GetPlayerPed(-1))) + \"\", 255, 255, 255, 255, 0);\\r\\n    if (GetPlayerWantedLevel(PlayerId()) != 0) {\\r\\n        SetPlayerWantedLevel(PlayerId(), 0, false);\\r\\n        SetPlayerWantedLevelNow(PlayerId(), false);\\r\\n    }\\r\\n});\\r\\nlet cl = false;\\r\\nKoi.registerCommand(\"test\", (src, args, raw) => __awaiter(void 0, void 0, void 0, function* () {\\r\\n    cl = !cl;\\r\\n    if (cl) {\\r\\n        return SwitchInPlayer(PlayerPedId());\\r\\n    }\\r\\n    return SwitchOutPlayer(PlayerPedId(), 0, 1);\\r\\n}));\\r\\nKoi.registerCommand(\"testa\", (src, args, raw) => __awaiter(void 0, void 0, void 0, function* () {\\r\\n    emitNet(\"Koi:ServerEncrypt\", \"data\", (result) => {\\r\\n        Notify(result);\\r\\n    });\\r\\n}));\\r\\nKoi.registerCommand(\"car\", (src, args, raw) => __awaiter(void 0, void 0, void 0, function* () {\\r\\n    let model = args[0] ? args[0].toString() : \"adder\";\\r\\n    let hash = GetHashKey(model);\\r\\n    if (!IsModelInCdimage(hash) || !IsModelAVehicle(hash)) {\\r\\n        emit(\"chat:addMessage\", {\\r\\n            args: [`It might have been a good thing that you tried to spawn a ${model}. Who even wants their spawning to actually ^*succeed?`],\\r\\n        });\\r\\n        return;\\r\\n    }\\r\\n    RequestModel(hash);\\r\\n    while (!HasModelLoaded(hash)) {\\r\\n        yield Koi.wait(500);\\r\\n    }\\r\\n    let ped = PlayerPedId();\\r\\n    // Get the coordinates of the player\\'s Ped (their character)\\r\\n    let coords = GetEntityCoords(ped, true);\\r\\n    // Create a vehicle at the player\\'s position\\r\\n    let vehicle = CreateVehicle(hash, coords[0], coords[1], coords[2], GetEntityHeading(ped), true, false);\\r\\n    // Set the player into the drivers seat of the vehicle\\r\\n    SetPedIntoVehicle(ped, vehicle, -1);\\r\\n    // Allow the game engine to clean up the vehicle and model if needed\\r\\n    SetEntityAsNoLongerNeeded(vehicle);\\r\\n    SetModelAsNoLongerNeeded(model);\\r\\n    // Tell the player the car spawned\\r\\n    emit(\"chat:addMessage\", {\\r\\n        args: [`Woohoo! Enjoy your new ^*${model}!`],\\r\\n    });\\r\\n}));\\r\\nKoi.registerCommand(\"dv\", (src, args, raw) => __awaiter(void 0, void 0, void 0, function* () {\\r\\n    let ped = GetPlayerPed(-1);\\r\\n    function DeleteGivenVehicle(veh, timeoutMax) {\\r\\n        let timeout = 0;\\r\\n        SetEntityAsMissionEntity(veh, true, true);\\r\\n        DeleteVehicle(veh);\\r\\n        if (DoesEntityExist(veh)) {\\r\\n            while (DoesEntityExist(veh) && timeout < timeoutMax) {\\r\\n                DeleteVehicle(veh);\\r\\n                if (!DoesEntityExist(veh)) {\\r\\n                    Notify(\"~g~Vehicle deleted.\");\\r\\n                }\\r\\n                timeout = timeout + 1;\\r\\n                Koi.wait(500);\\r\\n                if (DoesEntityExist(veh) && timeout == timeoutMax - 1) {\\r\\n                    Notify(\"~r~Failed to delete vehicle after \" + timeoutMax + \" retries.\");\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            Notify(\"~g~Vehicle deleted.\");\\r\\n        }\\r\\n    }\\r\\n    if (DoesEntityExist(ped) && !IsEntityDead(ped)) {\\r\\n        if (IsPedSittingInAnyVehicle(ped)) {\\r\\n            let vehicle = GetVehiclePedIsIn(ped, false);\\r\\n            if (GetPedInVehicleSeat(vehicle, -1) == ped) {\\r\\n                DeleteGivenVehicle(vehicle, 0);\\r\\n            }\\r\\n            else {\\r\\n                Notify(\"You must be in the driver\\'s seat!\");\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}), false);\\r\\nKoi.registerCommand(\"tpm\", (src, args, raw) => __awaiter(void 0, void 0, void 0, function* () {\\r\\n    let waypoint = GetFirstBlipInfoId(8);\\r\\n    if (DoesBlipExist(waypoint)) {\\r\\n        let coords = yield GetBlipInfoIdCoord(waypoint);\\r\\n        for (let height = 1; height <= 1000; height++) {\\r\\n            let [retval, groundZ] = GetGroundZFor_3dCoord(coords[0], coords[1], height, false);\\r\\n            SetPedCoordsKeepVehicle(PlayerPedId(), coords[0], coords[1], height);\\r\\n            if (groundZ) {\\r\\n                return emit(\"chat:addMessage\", {\\r\\n                    args: [`found the coord!`],\\r\\n                });\\r\\n            }\\r\\n            yield Koi.wait(5);\\r\\n        }\\r\\n    }\\r\\n}), false);\\r\\nKoi.registerCommand(\"tp\", (src, args, raw) => __awaiter(void 0, void 0, void 0, function* () {\\r\\n    return SetPedCoordsKeepVehicle(PlayerPedId(), args.x, args.y, args.z);\\r\\n}), false);\\r\\nKoi.registerCommand(\"coords\", (src, args, raw) => __awaiter(void 0, void 0, void 0, function* () {\\r\\n    let ped = PlayerPedId();\\r\\n    return Notify(GetEntityCoords(ped, true));\\r\\n}), false);\\r\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\\n\\n//# sourceURL=webpack:///./src/client/client.ts?')},\"./src/shared/shared.ts\":\n/*!******************************!*\\\n  !*** ./src/shared/shared.ts ***!\n  \\******************************/\n/*! no static exports found */function(module,exports,__webpack_require__){\"use strict\";eval('/* WEBPACK VAR INJECTION */(function(setImmediate) {\\r\\nObject.defineProperty(exports, \"__esModule\", { value: true });\\r\\nexports.encrypt = exports.wait = exports.registerCommand = void 0;\\r\\nconst registerCommand = (name, handler, config = false) => {\\r\\n    RegisterCommand(name, handler, config.restricted || false);\\r\\n    setImmediate(() => emitNet(\"chat:addSuggestion\", `/${name}`, config.description || \"No Description is Set\", config.argsDescription || []));\\r\\n    return true;\\r\\n};\\r\\nexports.registerCommand = registerCommand;\\r\\nconst wait = (ms) => new Promise((res) => setTimeout(res, ms));\\r\\nexports.wait = wait;\\r\\nconst encrypt = (data, callbackHandler) => {\\r\\n    return emitNet(\"Koi:ServerEncrypt\", data, callbackHandler);\\r\\n};\\r\\nexports.encrypt = encrypt;\\r\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))\\n\\n//# sourceURL=webpack:///./src/shared/shared.ts?')}});","extractedComments":[]}